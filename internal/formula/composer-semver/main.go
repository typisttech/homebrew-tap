package main

import (
	"fmt"
	"text/template"

	"github.com/google/go-github/v75/github"
	"context"
	"os"
	"strings"
	"slices"
	"path/filepath"
)

const (
	owner = "typisttech"
	repo  = "composer-semver"

	darwinARM64File = "composer-semver_Darwin_arm64.tar.gz"
	darwinAMD64File = "composer-semver_Darwin_amd64.tar.gz"
	linuxARM64File  = "composer-semver_Linux_arm64.tar.gz"
	linuxAMD64File  = "composer-semver_Linux_amd64.tar.gz"
)

const fileTemplateRaw = `# DO NOT EDIT THIS FILE
# This file is generated by "internal/formula/composer-semver/main.go"
class ComposerSemver < Formula
  desc "Static linked CLI wrapper for composer/semver. Parsing and validating versions exactly like Composer does without installing PHP."
  homepage "https://github.com/typisttech/composer-semver"
  version "{{ .Version }}"
  license "MIT"

  livecheck do
    url :stable
    strategy :github_latest do |json, regex|
      match = json["tag_name"]&.match(regex)
      next if match.blank?

      match[1]
    end
  end

  on_macos do
    if Hardware::CPU.arm?
      url "{{ .DarwinARM64URL }}"
      sha256 "{{ .DarwinARM64SHA256 }}"
    end
    if Hardware::CPU.intel?
      url "{{ .DarwinAMD64URL }}"
      sha256 "{{ .DarwinAMD64SHA256 }}"
    end
  end

  on_linux do
    if Hardware::CPU.arm? && Hardware::CPU.is_64_bit?
      url "{{ .LinuxARM64URL }}"
      sha256 "{{ .LinuxARM64SHA256 }}"
    end
    if Hardware::CPU.intel? && Hardware::CPU.is_64_bit?
      url "{{ .LinuxAMD64URL }}"
      sha256 "{{ .LinuxAMD64SHA256 }}"
    end
  end

  def install
    bin.install "composer-semver"
    generate_completions_from_executable(bin/"composer-semver", "completion")
  end

  test do
    assert_match "Composer SemVer v{{ .Version }}", shell_output("#{bin}/composer-semver --version")
  end
end
`

var fileTemplate = template.Must(template.New("").Parse(fileTemplateRaw))

type data struct {
	Version           string
	DarwinARM64URL    string
	DarwinARM64SHA256 string
	DarwinAMD64URL    string
	DarwinAMD64SHA256 string
	LinuxARM64URL     string
	LinuxARM64SHA256  string
	LinuxAMD64URL     string
	LinuxAMD64SHA256  string
}

func newData(r *github.RepositoryRelease, as []*github.ReleaseAsset) data {
	v := r.GetTagName()
	if strings.HasPrefix(v, "v") {
		v = v[1:]
	}

	return data{
		Version:           v,
		DarwinARM64URL:    findAssetURL(as, darwinARM64File),
		DarwinARM64SHA256: findAssetSHA256(as, darwinARM64File),
		DarwinAMD64URL:    findAssetURL(as, darwinAMD64File),
		DarwinAMD64SHA256: findAssetSHA256(as, darwinAMD64File),
		LinuxARM64URL:     findAssetURL(as, linuxARM64File),
		LinuxARM64SHA256:  findAssetSHA256(as, linuxARM64File),
		LinuxAMD64URL:     findAssetURL(as, linuxAMD64File),
		LinuxAMD64SHA256:  findAssetSHA256(as, linuxAMD64File),
	}
}

func findAssetURL(as []*github.ReleaseAsset, s string) string {
	a := findAsset(as, s)

	return a.GetBrowserDownloadURL()
}

func findAssetSHA256(as []*github.ReleaseAsset, s string) string {
	a := findAsset(as, s)

	d := a.GetDigest()
	if !strings.HasPrefix(d, "sha256:") {
		panic(fmt.Sprintf(`expect release asset %q digest to be prefixed with "sha256:", got: %q`, s, d))
	}

	return d[7:]
}

func findAsset(as []*github.ReleaseAsset, s string) *github.ReleaseAsset {
	i := slices.IndexFunc(as, func(a *github.ReleaseAsset) bool {
		return a.GetName() == s
	})

	if i < 0 {
		panic(fmt.Sprintf("release asset %q not found", s))
	}

	return as[i]
}

func newClient() *github.Client {
	client := github.NewClient(nil)

	token := os.Getenv("GH_TOKEN")
	if token == "" {
		fmt.Println("GH_TOKEN is not set. You may hit rate limits.")
		fmt.Println("Proceeding without authentication....")
	} else {
		fmt.Println("GH_TOKEN is set. Using authenticated client.")
		client = client.WithAuthToken(token)
	}
	return client
}

//go:generate go run main.go
func main() {
	fmt.Println("==> Generating Formula/composer-semver.rb...")

	ctx := context.Background()
	client := newClient()

	fmt.Println("Fetching the latest release...")
	release, _, err := client.Repositories.GetLatestRelease(ctx, owner, repo)
	if err != nil {
		fmt.Println("unable to fetch the latest release")
		panic(err)
	}

	fmt.Printf("Fetching %s release assets...\n", release.GetTagName())
	assets, _, err := client.Repositories.ListReleaseAssets(
		ctx,
		owner,
		repo,
		release.GetID(),
		&github.ListOptions{
			PerPage: 100,
			Page:    1,
		})

	d := newData(release, assets)

	f, err := os.Create("../../../Formula/composer-semver.rb")
	if err != nil {
		fmt.Println("unable to create file")
		panic(err)
	}
	defer f.Close()
	p, err := filepath.Abs(f.Name())
	if err != nil {
		fmt.Println("unable to get the absolute path of the file")
		panic(err)
	}
	fmt.Println("Writing the formula file to", p)

	err = fileTemplate.Execute(f, d)
	if err != nil {
		fmt.Println("unable to template the formula file")
		panic(err)
	}

	fmt.Println("Done!")
}
